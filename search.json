[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "I graduated from IIT Bombay 2014 with B.Tech in Civil Engg.\nThis is where i share my self leaning jouney and the lessons learned during my projects, spanning notebook-driven development, artificial intelligence and software design.\nPreviously I held positions of quant analyst, pricing fixed income products and derivatives, then worked as market risk analyst in a global Re Insurance firm (SwissRe). Before all of this i was a national athelete praticipating a laser and enterprise sailing with some successes.\nI LOVE SPORTS and TECH!"
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html",
    "href": "posts/31st day/Python_OOPs.html",
    "title": "Python OOPs fundamentals",
    "section": "",
    "text": "An introduction to Object Oriented programming using Python.\nIncreasingly it’s becoming important for Data professionals to become better at programming and modern programming is centered around Object Oriented programming paradigm. This article helps in explaining some important programming concepts which are mostly language agnostic but we will be using Python in this article.\nObject-oriented programming (OOPs) is a programming paradigm that relies on the concept of classes and objects. The basic idea of OOP is to divide a sophisticated program into a number of objects that interact with each other to achieve the desired functionality. There are several advantages of using OOP for data science:\nOverall, OOP can help data professionals organize and manage their code more effectively, making it easier to develop and maintain data science projects. Let’s dive into the OOPs concept."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#what-are-objects-and-classes",
    "href": "posts/31st day/Python_OOPs.html#what-are-objects-and-classes",
    "title": "Python OOPs fundamentals",
    "section": "1 What are Objects and Classes?",
    "text": "1 What are Objects and Classes?\nClasses are the blueprint for defining an Object. While an Object is a collection of data/properties and their behaviors/methods.\nFor example- Think of a class Bulb that will have a state (On/Off) and methods to turnOn and turnoff the bulb.\n\nclass Bulb():\n    def __init__(self, onOff=False): self.onOff = onOff    \n    def turnOn(self): self.onOff = True\n    def turnOff(self): self.onOff = False\n\nNow we can create multiple bulb objects from this Bulb class.\n\nb1 = Bulb(onOff=True)\nb2 = Bulb()\nprint(f\"Bulb 1 state is :{b1.onOff}, Bulb 2 state is :{b2.onOff}\")\n\nBulb 1 state is :True, Bulb 2 state is :False\n\n\nb1 and b2 are objects of the class Bulb. Let’s use the turnOn and turnOff methods to update the bulb properties.\n\nb1.turnOff(); b2.turnOn()\nprint(f\"Bulb 1 state is :{b1.onOff}, Bulb 2 state is :{b2.onOff}\")\n\nBulb 1 state is :False, Bulb 2 state is :True\n\n\nWe can see from the example above, a Bulb object contains the onOff property. Properties are variables that contain information regarding the object of a class and Methods like turnOn and turnOff in our Bulb class are functions that have access to the properties of a class. Methods can accept additional parameters, modify properties and return values."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#class-and-instance-variables",
    "href": "posts/31st day/Python_OOPs.html#class-and-instance-variables",
    "title": "Python OOPs fundamentals",
    "section": "2 Class and Instance variables",
    "text": "2 Class and Instance variables\nIn Python, properties can be defined in two ways -\n\nClass Variables - Class variables are shared by all objects of the class. A change in the class variable will change the value of that property in all the objects of the class.\nInstance Variables - Instance variables are unique to each instance or object of the class. A change in instance variable will change the value of the property in that specific object only.\n\n\nclass Employee:\n    # Creating a class variable\n    companyName = \"Apple\"\n    \n    def __init__(self, name):\n        # creating an instance variable\n        self.name = name\n    \ne1 = Employee('Abhi')\ne2 = Employee('Manyu')\n\nprint(f'Name :{e1.name}')\nprint(f'Company Name: {e1.companyName}')\nprint(f'Name :{e2.name}')\nprint(f'Company Name: {e2.companyName}')\n\nName :Abhi\nCompany Name: Apple\nName :Manyu\nCompany Name: Apple\n\n\nWe can see above, the class variable is defined outside of the initializer and the instance variable is defined inside the initializer.\n\nEmployee.companyName = \"Microsoft\"\nprint(e1.companyName, e2.companyName)\n\nmicrosoft microsoft\n\n\nWe can see above changing a class variable in the Employee class changes the class variable in all objects of the class. Most of the time we will be using instance variables but knowledge about class variables can come in handy. Let’s look at an interesting use of class variable -\n\nclass Employee:\n    # Creating a class variable\n    companyName = \"Microsoft\"\n    companyEmployees = []\n    \n    def __init__(self, name):\n        # creating an instance variable\n        self.name = name\n        self.companyEmployees.append(self.name)\n    \ne1 = Employee('Abhi')\ne2 = Employee('Manyu')\n\nprint(f'Name :{e1.name}')\nprint(f'Team Members: {e1.companyEmployees}')\nprint(f'Name :{e2.name}')\nprint(f'Company Name: {e2.companyEmployees}')\n\nName :Abhi\nTeam Members: ['Abhi', 'Manyu']\nName :Manyu\nCompany Name: ['Abhi', 'Manyu']\n\n\nWe can see above, we are saving all objects of the Employee class in companyEmployees which is a list shared by all objects of the class Employee."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#class-static-and-instance-methods",
    "href": "posts/31st day/Python_OOPs.html#class-static-and-instance-methods",
    "title": "Python OOPs fundamentals",
    "section": "3 Class, Static and Instance methods",
    "text": "3 Class, Static and Instance methods\nIn Python classes, we have three types of methods -\n\nClass Methods - Class methods work with class variables and are accessible using the class name rather than its object.\nStatic Methods - Static methods are methods that are usually limited to class only and not their objects. They don’t typically modify or access class and instance variables. They are used as utility functions inside the class and we don’t want the inherited class to modify them.\nInstance Methods - Instance methods are the most used methods and have access to instance variables within the class. They can also take new parameters to perform desired operations.\n\n\nclass Employee:\n    # Creating a class variable\n    companyName = \"Microsoft\"\n    companyEmployees = []\n    \n    def __init__(self, name):\n        # creating an instance variable\n        self.name = name\n        self.companyEmployees.append(self.name)\n    \n    @classmethod\n    def getCompanyName(cls): # This is a class method\n         return cls.companyName\n    \n    @staticmethod\n    def plusTwo(x): # This is a static method\n        return x+2\n    \n    def getName(self): # This is an instance method\n        return self.name\n    \ne1 = Employee('Abhi')\nprint(f\"Calling class method. Company name is {e1.getCompanyName()}\")\nprint(f\"Calling Static method. {e1.plusTwo(2)}\")\nprint(f\"Calling instance method. Employee name is {e1.getName()}\")\n\nCalling class method. Company name is Microsoft\nCalling Static method. 4\nCalling instance method. Employee name is Abhi\n\n\nWe can see above we use the @classmethod decorator to define the class method. cls is used to refer to the class just as self is used to refer to the object of the class. The class method at least takes one argument cls.\n\n\n\n\n\n\nNote\n\n\n\nWe can use any other name instead of cls but cls is used as a convention.\n\n\nWe use @staticmethod decorator to define static class plusTwo. We can see that static methods don’t take any argument like self and cls.\nThe most commonly used methods are instance methods and they can be defined without a decorator within the class. Just like the class method they take at least one argument which is self by convention.\n\n\n\n\n\n\nNote\n\n\n\nWe can use any other name instead of self but self is used as a convention."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#access-modifiers",
    "href": "posts/31st day/Python_OOPs.html#access-modifiers",
    "title": "Python OOPs fundamentals",
    "section": "4 Access Modifiers",
    "text": "4 Access Modifiers\nAccess modifiers limit access to the variables and functions of a class. There are three types of access modifiers - public, protected, and private.\n\n4.1 Public Attributes\nPublic attributes are those methods and properties which can be accessed anywhere inside and outside of the class. By default, all the member variables and functions are public.\n\nclass Employee:\n    def __init__(self, name):\n        self.name = name ## Public variable\n        \n    def getName(self): ## Public method\n        return self.name\n\ne1 = Employee(\"Abhi\")\nprint(f\"Employee Name: {e1.getName()}\")\n\nEmployee Name: Abhi\n\n\nIn the case above, both property name and method getName are public attributes.\n\n\n4.2 Protected Attributes\nProtected attributes are similar to public attributes which can be accessed within the class and also available to subclasses. The only difference is the convention, which is to define each protected member with a single underscore “_”.\n\nclass Employee:\n    def __init__(self, name, project):\n        self.name = name ## Public variable\n        self._project = project ## Protected variable\n        \n    def getName(self): ## Public method\n        return self.name\n    \n    def _getProject(self): ## Protected method\n        return self._project\n    \ne1 = Employee(\"Abhi\", \"Project Warpgate\")\nprint(f\"Employee Name: {e1.getName()}\")\nprint(f\"Project Name: {e1._getProject()}\")\n\nEmployee Name: Abhi\nProject Name: Project Warpgate\n\n\nIn the case above, both property _project and method _getProject are protected attributes.\n\n\n4.3 Private Attributes\nPrivate attributes are accessible within the class but not outside of the class. To define a private attribute, prefix the method or property with the double underscore”_“.\n\nclass Employee:\n    def __init__(self, name, project, salary):\n        self.name = name ## Public variable\n        self._project = project ## Protected variable\n        self.__salary = salary\n        \n    def getName(self): ## Public method\n        return self.name\n    \n    def _getProject(self): ## Protected method\n        return self._project\n    \n    def __getSalary(self): ## Protected method\n        return self.__salary\n    \ne1 = Employee(\"Abhi\", \"Project Warpgate\", \"3500\")\nprint(f\"Employee Name: {e1.getName()}\")\nprint(f\"Project Name: {e1.__getSalary()}\") \n\nEmployee Name: Abhi\n\n\nAttributeError: 'Employee' object has no attribute '__getSalary'\n\n\nWe can see above, __salary property and __getSalary method are both private attributes and when we call them outside of the class they throw an error that the 'Employee' object has no attribute '__getSalary'."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#encapsulation",
    "href": "posts/31st day/Python_OOPs.html#encapsulation",
    "title": "Python OOPs fundamentals",
    "section": "5 Encapsulation",
    "text": "5 Encapsulation\nEncapsulation in OOP refers to binding data and the methods to manipulate that data together in a single unit, that is, class. Encapsulation is usually used to hide the state and representation of the object from the outside. A good use of encapsulation is to make all properties private of a class to prevent direct access from outside and use public methods to let the outside world communicate with the class.\n\nclass Employee:\n    def __init__(self, name, project, salary):\n        self.__name = name ## Public variable\n        self.__project = project ## Protected variable\n        self.__salary = salary\n        \n    def getName(self): ## Public method\n        return self.__name\n    \ne1 = Employee(\"Abhi\", \"Project Warpgate\", \"3500\")\nprint(f\"Employee Name: {e1.getName()}\")\n\nEmployee Name: Abhi\n\n\nEncapsulation has several advantages -\n\nProperties of the class can be hidden from the outside world\nMore control over what the outside world can access from the class\n\nA good example of encapsulation would be an access control class based on username and password.\n\nclass Auth:\n    def __init__(self, userName=None, password=None):\n        self.__userName = userName\n        self.__password = password\n        \n    def login(self, userName, password):\n        if (self.__userName == userName) and (self.__password == password):\n            print (f\"Access granted to {userName}\")\n        else:\n            print(\"Invalid credentials\")\n            \ne1 = Auth(\"Abhi\", \"whatever\")\ne1.login(\"Abhi\", \"whatever\") ## This will grant access\n\ne1.login(\"Abhi\", \"aasdasd\") ## This will say invalid creds\ne1.__password ## This will raise an error as private properties can't be accessed from outside.\n\nAccess granted to Abhi\nInvalid credentials\n\n\nAttributeError: 'Auth' object has no attribute '__password'\n\n\nAs we can see above __username and __password are protected properties and can only be used by the class to grand or reject access requests."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#inheritance",
    "href": "posts/31st day/Python_OOPs.html#inheritance",
    "title": "Python OOPs fundamentals",
    "section": "6 Inheritance",
    "text": "6 Inheritance\nInheritance provides a way to create new classes from the existing classes. The new class will inherit all the non-private attributes(properties and methods) from the existing class. The new class can be called a child class and the existing class can be called a parent class.\n\nimport math\nclass Shape:\n    def __init__(self, name):\n        self.name = name\n        \n    def getArea(self):\n        pass\n    \n    def printDetails(self):\n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \nclass Square(Shape):\n    def __init__(self, edge):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Square\")\n        self.edge = edge\n    \n    ## Overiding the getArea function\n    def getArea(self):\n        return self.edge**2\n    \nclass Circle(Shape):\n    def __init__(self, radius):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Circle\")\n        self.radius = radius\n    ## Overiding the getArea function\n    def getArea(self):\n        return math.pi * (self.radius**2)\n    \nobj1 = Square(4)\nobj1.printDetails()\n\nobj2 = Circle(3)\nobj2.printDetails()\n\nThis shape is called Square and area is 16.\nThis shape is called Circle and area is 28.274333882308138.\n\n\nWe can see above we defined a parent class Shape and then we inherited it to create a Square and Circle child class. While defining the Square and Circle class we overwrote the getArea function pertinent to the class but we used the printDetails function from the parent class to print details about child classes. The more common example in the machine learning world would be to create your own models in Pytorch where we inherit from nn.Module class to create a new model.\n\n6.1 Use of super() Function\nsuper() function comes into play when we implement inheritance. The super() function is used to refer to the parent class without explicitly naming the class. super() function can be used to access parent class properties, calling the parent class, and can be used as initializers. Let’s look at the example above and see how we can modify the Square class to use super() function.\n\nclass Shape:\n    maxArea = 100\n    def __init__(self, name): self.name = name\n    def getArea(self): pass\n    def printDetails(self): \n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \n\nclass Square(Shape):\n    maxArea = 50\n    def __init__(self, edge):\n        super().__init__(name = \"Square\") ## Initializing parent class\n        self.edge = edge\n    \n    def getName(self):\n        return super().maxArea\n    \n    def getArea(self):\n        return self.edge**2\n    \n    def printDetails(self):\n        super().printDetails() ## Calling a parent class function\n        print(f\"Max area from Shape class: {super().maxArea}\") ## Accessing parent class property\n        print(f\"Max area from Square class: {self.maxArea}\")\n\nobj1 = Square(4)\nobj1.getName()\nobj1.printDetails()\n\nThis shape is called Square and area is 16.\nMax area from Shape class: 100\nMax area from Square class: 50\n\n\nAs we can see in the example above we have used -\n\nsuper().__init__ to initialize the parent Shape class\nsuper().printDetails() function to use a method from parent class\nsuper().maxArea to access a property of a parent class\n\nThere are many advantages of inheritance -\n\nReusability - Inheritance makes the code reusable. Common methods and properties can be stored in a parent class and child classes can inherit these methods.\nModification - Code modification becomes easier if we use inheritance, if we want to make a change in the base class function it will be propagated to the child classes.\nExtensibility - We can derive new classes from the old ones by keeping things we need in the derived class."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#polymorphism",
    "href": "posts/31st day/Python_OOPs.html#polymorphism",
    "title": "Python OOPs fundamentals",
    "section": "7 Polymorphism",
    "text": "7 Polymorphism\nPolymorphism refers to the same object exhibiting different forms and behaviors. For example consider our shape class which could be a square, rectangle, polygon, etc. Instead of writing multiple functions to get the area of these shapes, we can use a common function like getArea() and implement this function in the derived class.\n\nimport math\nclass Shape:\n    def __init__(self, name):\n        self.name = name\n        \n    def getArea(self):\n        pass\n    \n    def printDetails(self):\n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \nclass Square(Shape):\n    def __init__(self, edge):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Square\")\n        self.edge = edge\n    \n    ## Overiding the getArea function\n    def getArea(self):\n        return self.edge**2\n    \nclass Circle(Shape):\n    def __init__(self, radius):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Circle\")\n        self.radius = radius\n    ## Overiding the getArea function\n    def getArea(self):\n        return math.pi * (self.radius**2)\n    \nobj1 = Square(4)\nprint(f\"Area of this {obj1.name} is {obj1.getArea()}\")\n\nobj2 = Circle(3)\nprint(f\"Area of this {obj2.name} is {obj2.getArea()}\")\n\nArea of this Square is 16\nArea of this Circle is 28.274333882308138\n\n\nAs we can see above there is a pre-defined dummy method called getArea in the Shape class. We override this method in the Square and Circle class. This technique is called method overriding. The advantage of method overriding is that the derived class can write its own specific implementation based on the requirement while using the same function name.\n\n7.1 Abstract base classes\nAbstract base classes define a set of methods and properties that a class must implement in order to inherit the parent class. This is a useful technique to enforce that certain functions within the derived class must exist. To define an abstract base class, we use the abc module. The abstract base class inherits from the built-in ABC class and we use the decorator @abstractmethod to declare an abstract method.\n\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    def __init__(self, name):\n        self.name = name\n    \n    @abstractmethod\n    def getArea(self):\n        pass\n    \n    def printDetails(self):\n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \nclass Square(Shape):\n    def __init__(self, edge):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Square\")\n        self.edge = edge\n    \nobj1 = Square(4)\nprint(f\"Area of this {obj1.name} is {obj1.getArea()}\")\n\nTypeError: Can't instantiate abstract class Square with abstract method getArea\n\n\nWe can see above that we have created a Shape class from the ABC class which has an abstract method getArea. Since our child class Square didn’t have getArea implemented we get an error instantiating this class.\n\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    def __init__(self, name):\n        self.name = name\n    \n    @abstractmethod\n    def getArea(self):\n        pass\n    \n    def printDetails(self):\n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \nclass Square(Shape):\n    def __init__(self, edge):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Square\")\n        self.edge = edge\n    \n    def getArea(self): return self.edge**2\n    \nobj1 = Square(4)\nprint(f\"Area of this {obj1.name} is {obj1.getArea()}\")\n\nArea of this Square is 16\n\n\nWe can see above, once we implemented the getArea method, the code runs fine.\n\nAbstract base classes serve as a blueprint for derived classes to implement methods that are required to run the function appropriately."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#conclusion",
    "href": "posts/31st day/Python_OOPs.html#conclusion",
    "title": "Python OOPs fundamentals",
    "section": "8 Conclusion",
    "text": "8 Conclusion\nIn this article, we learned about what is object-oriented programming and key concepts using Python. A good understanding of these concepts will lay a solid foundation for any software professional to write and understand python code better.\nI hope you enjoyed reading it. If there is any feedback on the code or just the blog post, feel free to comment below or reach out on Twitter."
  },
  {
    "objectID": "posts/2024-1-27-Blog-Setup/index.html",
    "href": "posts/2024-1-27-Blog-Setup/index.html",
    "title": "How I created this Blog",
    "section": "",
    "text": "Blogging is an essential part of a robust learning methodology, therefore, I decided to follow the advice and start my blog to document my “Machine Learning Journey”. Here are the steps it took to create this blog.\nThere is a good tutorial, but honestly I found it a bit intimidating because it is not a simple step-by-step guide, also the Creating a Blog page did not quite fit this category (for me). Therefore, without being an expert at this, let me share what I did to create this blog.\nSo if your goal is to create a simple blog based on Quarto, just hop on and follow along :).\nA little side-note: This is the second blog post I write with Quarto, and by now I feel that some rough edged have been removed, mostly because I realized that really all the blogging can be done in jupyter notebook! Therefore, learning, running my own experiments and blogging happen in the same environment and with a lot of reuse. Knowing that many more things can be done, the only goal of this blog post is to get you up and running with a basic setup and explain the possibility to blog via jupyter notebooks."
  },
  {
    "objectID": "posts/2024-1-27-Blog-Setup/index.html#step-1-create-a-new-github-repo",
    "href": "posts/2024-1-27-Blog-Setup/index.html#step-1-create-a-new-github-repo",
    "title": "How I created this Blog",
    "section": "Step 1: Create a new GitHub repo",
    "text": "Step 1: Create a new GitHub repo\nYour blog will reside in a GitHub repo, and it will leverage Github Pages. Follow steps 1 and 2 on the GitHub Pages homepage for the initial setup.\n\nNote: The default recommendation for the repo is &lt;your username&gt;.github.io. I took that recommendation, but anything else should work as well.\n\nAs a result you have an empty repo with just a readme.md file. Here’s how it still looks in my repo.\nFor cloning the repo to my local machine, I did:\ngit clone git@github.com:ekshunyam/ekshunyam.github.io\nTwo final activities are needed to finalize the setup of your repo:\n\nCreate a new branch called gh-pages. To do this, go to your branches (for me that is https://github.com/ekshunyam/ekshunyam.github.io/branches), and create the new branch by clicking the “New branch”-button in the top right.\nSet the new branch as the branch for GitHub Pages. In your repo, navigate to Settings -&gt; Pages. (In my repo that takes me to https://github.com/chrwittm/chrwittm.github.io/settings/pages.) Change main to gh-pages.\n\n\nFor more info on setting the branch, please refer to the Quarto Docs."
  },
  {
    "objectID": "posts/2024-1-27-Blog-Setup/index.html#step-2-install-quarto",
    "href": "posts/2024-1-27-Blog-Setup/index.html#step-2-install-quarto",
    "title": "How I created this Blog",
    "section": "Step 2: Install Quarto",
    "text": "Step 2: Install Quarto\nI am currently working on a Mac M1 machine and I started using Jupyter for both blogging and development workloads.\n\nInstalling Quarto with nbdev\nFrom previous activities with nbdev, I already had Quarto installed. If I re-traced my steps correctly, here is what I did (as suggested here and here):\nmamba install -c fastchan nbdev\nnbdev_install_quarto\nOptional: Once I discovered that I can do everything in jupyter, I would label this step as optional, because I only used the installation of Quarto to render previews of .qmd-files - which I do not need anymore when everything is done in jupyter notebooks.\nI also installed the Quarto extension for VS Code. just have have some flexibility interms of the IDE."
  },
  {
    "objectID": "posts/2024-1-27-Blog-Setup/index.html#step-3-initial-setup-to-publish-hello-world",
    "href": "posts/2024-1-27-Blog-Setup/index.html#step-3-initial-setup-to-publish-hello-world",
    "title": "How I created this Blog",
    "section": "Step 3: Initial setup to publish “Hello World”",
    "text": "Step 3: Initial setup to publish “Hello World”\nBy now we are really close to publishing the “Hello World”-version of our blog: In the command line, go to the directory of your repo, and run the following commands, and the example content for the Quarto blog should be published to your repo.\nquarto create-project --type website:blog\nquarto publish gh-pages\nOnce done, you can open your blog at: &lt;https://\"your username\".github.io/&gt;\nFor some more background on what is happening with these two commands, please refer to this this page (choose “Terminal”) and this page."
  },
  {
    "objectID": "posts/2024-1-27-Blog-Setup/index.html#step-4-create-your-first-blog-post",
    "href": "posts/2024-1-27-Blog-Setup/index.html#step-4-create-your-first-blog-post",
    "title": "How I created this Blog",
    "section": "Step 4: Create your first Blog Post",
    "text": "Step 4: Create your first Blog Post\nNow it is time to create your first own blog post.\nIn the posts-directory, create a new folder, for example hello-world. Within this folder, create a notebook called index.ipynb. Add some hello-world content and a RAW-section as the first cell with this content (here is an example):\n---\ntitle: \"Hello World\"\nauthor: \"Your Name\"\ndate: \"2022-01-01\"\n---\nRepublish your blog:\nquarto publish gh-pages\nCongratulations, you just published your first blog post!\nFor a little more detailed version of the hello world blog post, please feel free to reach out."
  },
  {
    "objectID": "posts/2024-1-27-Blog-Setup/index.html#step-5-avoiding-disaster",
    "href": "posts/2024-1-27-Blog-Setup/index.html#step-5-avoiding-disaster",
    "title": "How I created this Blog",
    "section": "Step 5: Avoiding Disaster",
    "text": "Step 5: Avoiding Disaster\nWhen you run quarto publish gh-pages, your blog posts are rendered, and the rendered versions are pushed to git in branch gh-pages. Your actual notebooks are not uploaded to GitHub. Also any config you make to the blog etc. is uploaded in the rendered versions only. So if something were to happen to your local files, your work would be lost. (Such a disaster almost happened to me but the OneDrive file history saved me.)\nTherefore, I would recommend to also upload the “source”-files to GitHub (in the main branch):\ngit add posts/\ngit add _quarto.yml\ngit add about.qmd\ngit add index.qmd\ngit add profile.png\ngit add styles.css\ngit add .gitignore\ngit commit -m \"uploaded source files\"\ngit push\nAs a result, the source files are also stored on GitHub."
  },
  {
    "objectID": "posts/2024-1-27-Blog-Setup/index.html#steps-6-to-n-additional-setup",
    "href": "posts/2024-1-27-Blog-Setup/index.html#steps-6-to-n-additional-setup",
    "title": "How I created this Blog",
    "section": "Steps 6 to n: Additional setup",
    "text": "Steps 6 to n: Additional setup\nThere are many more things that can be done with the blog, but to keep things down to basics, let me just mention a few topics which will make the blog look like your own blog.\nAdditionally, let me mention one other blog post as a reference which I found only when looking into more detailed setup topics like comments and analytics. Albert Rapp’s blog post The ultimate guide to starting a Quarto blog truly is a great guide for setting up your Quarto blog.\n\nStep 6.1: Remove example content\nNow that the hello world blog post is published, you can remove the default content. I just turned the two example blog posts into drafts by adding the following line in their headers:\ndraft: true\n\n\nStep 6.2: Update remaining example content\nUpdate the following files and add/change the content, so that the blog looks like it is your blog:\n_quarto.yml\nabout.qmd\nindex.qmd"
  },
  {
    "objectID": "posts/2024-1-27-Blog-Setup/index.html#conclusion",
    "href": "posts/2024-1-27-Blog-Setup/index.html#conclusion",
    "title": "How I created this Blog",
    "section": "Conclusion",
    "text": "Conclusion\nSetting up the blog was not really hard, but it took some time for me. Hopefully, this guide contains some shortcuts for you. Happy blogging!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Experiments with Tech",
    "section": "",
    "text": "How I created this Blog\n\n\n\n\n\n\n\nblogging\n\n\nquarto\n\n\njupyter\n\n\n\n\n\n\n\n\n\n\n\nJan 27, 2024\n\n\nAbhi\n\n\n\n\n\n\n  \n\n\n\n\nPython OOPs fundamentals\n\n\n\n\n\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 31, 2023\n\n\nAbhi\n\n\n\n\n\n\nNo matching items"
  }
]