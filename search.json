[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "I graduated from IIT Bombay 2014 with B.Tech in Civil Engg.\nThis is where i share my self leaning jouney and the lessons learned during my projects, spanning notebook-driven development, artificial intelligence and software design.\nPreviously I held positions of quant analyst, pricing fixed income products and derivatives, then worked as market risk analyst in a global Re Insurance firm (SwissRe). Before all of this i was a national athelete praticipating a laser and enterprise sailing with some successes.\nI LOVE SPORTS and TECH!"
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html",
    "href": "posts/31st day/Python_OOPs.html",
    "title": "Python OOPs fundamentals",
    "section": "",
    "text": "An introduction to Object Oriented programming using Python.\nIncreasingly it’s becoming important for Data professionals to become better at programming and modern programming is centered around Object Oriented programming paradigm. This article helps in explaining some important programming concepts which are mostly language agnostic but we will be using Python in this article.\nObject-oriented programming (OOPs) is a programming paradigm that relies on the concept of classes and objects. The basic idea of OOP is to divide a sophisticated program into a number of objects that interact with each other to achieve the desired functionality. There are several advantages of using OOP for data science:\nOverall, OOP can help data professionals organize and manage their code more effectively, making it easier to develop and maintain data science projects. Let’s dive into the OOPs concept."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#what-are-objects-and-classes",
    "href": "posts/31st day/Python_OOPs.html#what-are-objects-and-classes",
    "title": "Python OOPs fundamentals",
    "section": "1 What are Objects and Classes?",
    "text": "1 What are Objects and Classes?\nClasses are the blueprint for defining an Object. While an Object is a collection of data/properties and their behaviors/methods.\nFor example- Think of a class Bulb that will have a state (On/Off) and methods to turnOn and turnoff the bulb.\n\nclass Bulb():\n    def __init__(self, onOff=False): self.onOff = onOff    \n    def turnOn(self): self.onOff = True\n    def turnOff(self): self.onOff = False\n\nNow we can create multiple bulb objects from this Bulb class.\n\nb1 = Bulb(onOff=True)\nb2 = Bulb()\nprint(f\"Bulb 1 state is :{b1.onOff}, Bulb 2 state is :{b2.onOff}\")\n\nBulb 1 state is :True, Bulb 2 state is :False\n\n\nb1 and b2 are objects of the class Bulb. Let’s use the turnOn and turnOff methods to update the bulb properties.\n\nb1.turnOff(); b2.turnOn()\nprint(f\"Bulb 1 state is :{b1.onOff}, Bulb 2 state is :{b2.onOff}\")\n\nBulb 1 state is :False, Bulb 2 state is :True\n\n\nWe can see from the example above, a Bulb object contains the onOff property. Properties are variables that contain information regarding the object of a class and Methods like turnOn and turnOff in our Bulb class are functions that have access to the properties of a class. Methods can accept additional parameters, modify properties and return values."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#class-and-instance-variables",
    "href": "posts/31st day/Python_OOPs.html#class-and-instance-variables",
    "title": "Python OOPs fundamentals",
    "section": "2 Class and Instance variables",
    "text": "2 Class and Instance variables\nIn Python, properties can be defined in two ways -\n\nClass Variables - Class variables are shared by all objects of the class. A change in the class variable will change the value of that property in all the objects of the class.\nInstance Variables - Instance variables are unique to each instance or object of the class. A change in instance variable will change the value of the property in that specific object only.\n\n\nclass Employee:\n    # Creating a class variable\n    companyName = \"Apple\"\n    \n    def __init__(self, name):\n        # creating an instance variable\n        self.name = name\n    \ne1 = Employee('Abhi')\ne2 = Employee('Manyu')\n\nprint(f'Name :{e1.name}')\nprint(f'Company Name: {e1.companyName}')\nprint(f'Name :{e2.name}')\nprint(f'Company Name: {e2.companyName}')\n\nName :Abhi\nCompany Name: Apple\nName :Manyu\nCompany Name: Apple\n\n\nWe can see above, the class variable is defined outside of the initializer and the instance variable is defined inside the initializer.\n\nEmployee.companyName = \"Microsoft\"\nprint(e1.companyName, e2.companyName)\n\nmicrosoft microsoft\n\n\nWe can see above changing a class variable in the Employee class changes the class variable in all objects of the class. Most of the time we will be using instance variables but knowledge about class variables can come in handy. Let’s look at an interesting use of class variable -\n\nclass Employee:\n    # Creating a class variable\n    companyName = \"Microsoft\"\n    companyEmployees = []\n    \n    def __init__(self, name):\n        # creating an instance variable\n        self.name = name\n        self.companyEmployees.append(self.name)\n    \ne1 = Employee('Abhi')\ne2 = Employee('Manyu')\n\nprint(f'Name :{e1.name}')\nprint(f'Team Members: {e1.companyEmployees}')\nprint(f'Name :{e2.name}')\nprint(f'Company Name: {e2.companyEmployees}')\n\nName :Abhi\nTeam Members: ['Abhi', 'Manyu']\nName :Manyu\nCompany Name: ['Abhi', 'Manyu']\n\n\nWe can see above, we are saving all objects of the Employee class in companyEmployees which is a list shared by all objects of the class Employee."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#class-static-and-instance-methods",
    "href": "posts/31st day/Python_OOPs.html#class-static-and-instance-methods",
    "title": "Python OOPs fundamentals",
    "section": "3 Class, Static and Instance methods",
    "text": "3 Class, Static and Instance methods\nIn Python classes, we have three types of methods -\n\nClass Methods - Class methods work with class variables and are accessible using the class name rather than its object.\nStatic Methods - Static methods are methods that are usually limited to class only and not their objects. They don’t typically modify or access class and instance variables. They are used as utility functions inside the class and we don’t want the inherited class to modify them.\nInstance Methods - Instance methods are the most used methods and have access to instance variables within the class. They can also take new parameters to perform desired operations.\n\n\nclass Employee:\n    # Creating a class variable\n    companyName = \"Microsoft\"\n    companyEmployees = []\n    \n    def __init__(self, name):\n        # creating an instance variable\n        self.name = name\n        self.companyEmployees.append(self.name)\n    \n    @classmethod\n    def getCompanyName(cls): # This is a class method\n         return cls.companyName\n    \n    @staticmethod\n    def plusTwo(x): # This is a static method\n        return x+2\n    \n    def getName(self): # This is an instance method\n        return self.name\n    \ne1 = Employee('Abhi')\nprint(f\"Calling class method. Company name is {e1.getCompanyName()}\")\nprint(f\"Calling Static method. {e1.plusTwo(2)}\")\nprint(f\"Calling instance method. Employee name is {e1.getName()}\")\n\nCalling class method. Company name is Microsoft\nCalling Static method. 4\nCalling instance method. Employee name is Abhi\n\n\nWe can see above we use the @classmethod decorator to define the class method. cls is used to refer to the class just as self is used to refer to the object of the class. The class method at least takes one argument cls.\n\n\n\n\n\n\nNote\n\n\n\nWe can use any other name instead of cls but cls is used as a convention.\n\n\nWe use @staticmethod decorator to define static class plusTwo. We can see that static methods don’t take any argument like self and cls.\nThe most commonly used methods are instance methods and they can be defined without a decorator within the class. Just like the class method they take at least one argument which is self by convention.\n\n\n\n\n\n\nNote\n\n\n\nWe can use any other name instead of self but self is used as a convention."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#access-modifiers",
    "href": "posts/31st day/Python_OOPs.html#access-modifiers",
    "title": "Python OOPs fundamentals",
    "section": "4 Access Modifiers",
    "text": "4 Access Modifiers\nAccess modifiers limit access to the variables and functions of a class. There are three types of access modifiers - public, protected, and private.\n\n4.1 Public Attributes\nPublic attributes are those methods and properties which can be accessed anywhere inside and outside of the class. By default, all the member variables and functions are public.\n\nclass Employee:\n    def __init__(self, name):\n        self.name = name ## Public variable\n        \n    def getName(self): ## Public method\n        return self.name\n\ne1 = Employee(\"Abhi\")\nprint(f\"Employee Name: {e1.getName()}\")\n\nEmployee Name: Abhi\n\n\nIn the case above, both property name and method getName are public attributes.\n\n\n4.2 Protected Attributes\nProtected attributes are similar to public attributes which can be accessed within the class and also available to subclasses. The only difference is the convention, which is to define each protected member with a single underscore “_”.\n\nclass Employee:\n    def __init__(self, name, project):\n        self.name = name ## Public variable\n        self._project = project ## Protected variable\n        \n    def getName(self): ## Public method\n        return self.name\n    \n    def _getProject(self): ## Protected method\n        return self._project\n    \ne1 = Employee(\"Abhi\", \"Project Warpgate\")\nprint(f\"Employee Name: {e1.getName()}\")\nprint(f\"Project Name: {e1._getProject()}\")\n\nEmployee Name: Abhi\nProject Name: Project Warpgate\n\n\nIn the case above, both property _project and method _getProject are protected attributes.\n\n\n4.3 Private Attributes\nPrivate attributes are accessible within the class but not outside of the class. To define a private attribute, prefix the method or property with the double underscore”_“.\n\nclass Employee:\n    def __init__(self, name, project, salary):\n        self.name = name ## Public variable\n        self._project = project ## Protected variable\n        self.__salary = salary\n        \n    def getName(self): ## Public method\n        return self.name\n    \n    def _getProject(self): ## Protected method\n        return self._project\n    \n    def __getSalary(self): ## Protected method\n        return self.__salary\n    \ne1 = Employee(\"Abhi\", \"Project Warpgate\", \"3500\")\nprint(f\"Employee Name: {e1.getName()}\")\nprint(f\"Project Name: {e1.__getSalary()}\") \n\nEmployee Name: Abhi\n\n\nAttributeError: 'Employee' object has no attribute '__getSalary'\n\n\nWe can see above, __salary property and __getSalary method are both private attributes and when we call them outside of the class they throw an error that the 'Employee' object has no attribute '__getSalary'."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#encapsulation",
    "href": "posts/31st day/Python_OOPs.html#encapsulation",
    "title": "Python OOPs fundamentals",
    "section": "5 Encapsulation",
    "text": "5 Encapsulation\nEncapsulation in OOP refers to binding data and the methods to manipulate that data together in a single unit, that is, class. Encapsulation is usually used to hide the state and representation of the object from the outside. A good use of encapsulation is to make all properties private of a class to prevent direct access from outside and use public methods to let the outside world communicate with the class.\n\nclass Employee:\n    def __init__(self, name, project, salary):\n        self.__name = name ## Public variable\n        self.__project = project ## Protected variable\n        self.__salary = salary\n        \n    def getName(self): ## Public method\n        return self.__name\n    \ne1 = Employee(\"Abhi\", \"Project Warpgate\", \"3500\")\nprint(f\"Employee Name: {e1.getName()}\")\n\nEmployee Name: Abhi\n\n\nEncapsulation has several advantages -\n\nProperties of the class can be hidden from the outside world\nMore control over what the outside world can access from the class\n\nA good example of encapsulation would be an access control class based on username and password.\n\nclass Auth:\n    def __init__(self, userName=None, password=None):\n        self.__userName = userName\n        self.__password = password\n        \n    def login(self, userName, password):\n        if (self.__userName == userName) and (self.__password == password):\n            print (f\"Access granted to {userName}\")\n        else:\n            print(\"Invalid credentials\")\n            \ne1 = Auth(\"Abhi\", \"whatever\")\ne1.login(\"Abhi\", \"whatever\") ## This will grant access\n\ne1.login(\"Abhi\", \"aasdasd\") ## This will say invalid creds\ne1.__password ## This will raise an error as private properties can't be accessed from outside.\n\nAccess granted to Abhi\nInvalid credentials\n\n\nAttributeError: 'Auth' object has no attribute '__password'\n\n\nAs we can see above __username and __password are protected properties and can only be used by the class to grand or reject access requests."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#inheritance",
    "href": "posts/31st day/Python_OOPs.html#inheritance",
    "title": "Python OOPs fundamentals",
    "section": "6 Inheritance",
    "text": "6 Inheritance\nInheritance provides a way to create new classes from the existing classes. The new class will inherit all the non-private attributes(properties and methods) from the existing class. The new class can be called a child class and the existing class can be called a parent class.\n\nimport math\nclass Shape:\n    def __init__(self, name):\n        self.name = name\n        \n    def getArea(self):\n        pass\n    \n    def printDetails(self):\n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \nclass Square(Shape):\n    def __init__(self, edge):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Square\")\n        self.edge = edge\n    \n    ## Overiding the getArea function\n    def getArea(self):\n        return self.edge**2\n    \nclass Circle(Shape):\n    def __init__(self, radius):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Circle\")\n        self.radius = radius\n    ## Overiding the getArea function\n    def getArea(self):\n        return math.pi * (self.radius**2)\n    \nobj1 = Square(4)\nobj1.printDetails()\n\nobj2 = Circle(3)\nobj2.printDetails()\n\nThis shape is called Square and area is 16.\nThis shape is called Circle and area is 28.274333882308138.\n\n\nWe can see above we defined a parent class Shape and then we inherited it to create a Square and Circle child class. While defining the Square and Circle class we overwrote the getArea function pertinent to the class but we used the printDetails function from the parent class to print details about child classes. The more common example in the machine learning world would be to create your own models in Pytorch where we inherit from nn.Module class to create a new model.\n\n6.1 Use of super() Function\nsuper() function comes into play when we implement inheritance. The super() function is used to refer to the parent class without explicitly naming the class. super() function can be used to access parent class properties, calling the parent class, and can be used as initializers. Let’s look at the example above and see how we can modify the Square class to use super() function.\n\nclass Shape:\n    maxArea = 100\n    def __init__(self, name): self.name = name\n    def getArea(self): pass\n    def printDetails(self): \n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \n\nclass Square(Shape):\n    maxArea = 50\n    def __init__(self, edge):\n        super().__init__(name = \"Square\") ## Initializing parent class\n        self.edge = edge\n    \n    def getName(self):\n        return super().maxArea\n    \n    def getArea(self):\n        return self.edge**2\n    \n    def printDetails(self):\n        super().printDetails() ## Calling a parent class function\n        print(f\"Max area from Shape class: {super().maxArea}\") ## Accessing parent class property\n        print(f\"Max area from Square class: {self.maxArea}\")\n\nobj1 = Square(4)\nobj1.getName()\nobj1.printDetails()\n\nThis shape is called Square and area is 16.\nMax area from Shape class: 100\nMax area from Square class: 50\n\n\nAs we can see in the example above we have used -\n\nsuper().__init__ to initialize the parent Shape class\nsuper().printDetails() function to use a method from parent class\nsuper().maxArea to access a property of a parent class\n\nThere are many advantages of inheritance -\n\nReusability - Inheritance makes the code reusable. Common methods and properties can be stored in a parent class and child classes can inherit these methods.\nModification - Code modification becomes easier if we use inheritance, if we want to make a change in the base class function it will be propagated to the child classes.\nExtensibility - We can derive new classes from the old ones by keeping things we need in the derived class."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#polymorphism",
    "href": "posts/31st day/Python_OOPs.html#polymorphism",
    "title": "Python OOPs fundamentals",
    "section": "7 Polymorphism",
    "text": "7 Polymorphism\nPolymorphism refers to the same object exhibiting different forms and behaviors. For example consider our shape class which could be a square, rectangle, polygon, etc. Instead of writing multiple functions to get the area of these shapes, we can use a common function like getArea() and implement this function in the derived class.\n\nimport math\nclass Shape:\n    def __init__(self, name):\n        self.name = name\n        \n    def getArea(self):\n        pass\n    \n    def printDetails(self):\n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \nclass Square(Shape):\n    def __init__(self, edge):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Square\")\n        self.edge = edge\n    \n    ## Overiding the getArea function\n    def getArea(self):\n        return self.edge**2\n    \nclass Circle(Shape):\n    def __init__(self, radius):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Circle\")\n        self.radius = radius\n    ## Overiding the getArea function\n    def getArea(self):\n        return math.pi * (self.radius**2)\n    \nobj1 = Square(4)\nprint(f\"Area of this {obj1.name} is {obj1.getArea()}\")\n\nobj2 = Circle(3)\nprint(f\"Area of this {obj2.name} is {obj2.getArea()}\")\n\nArea of this Square is 16\nArea of this Circle is 28.274333882308138\n\n\nAs we can see above there is a pre-defined dummy method called getArea in the Shape class. We override this method in the Square and Circle class. This technique is called method overriding. The advantage of method overriding is that the derived class can write its own specific implementation based on the requirement while using the same function name.\n\n7.1 Abstract base classes\nAbstract base classes define a set of methods and properties that a class must implement in order to inherit the parent class. This is a useful technique to enforce that certain functions within the derived class must exist. To define an abstract base class, we use the abc module. The abstract base class inherits from the built-in ABC class and we use the decorator @abstractmethod to declare an abstract method.\n\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    def __init__(self, name):\n        self.name = name\n    \n    @abstractmethod\n    def getArea(self):\n        pass\n    \n    def printDetails(self):\n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \nclass Square(Shape):\n    def __init__(self, edge):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Square\")\n        self.edge = edge\n    \nobj1 = Square(4)\nprint(f\"Area of this {obj1.name} is {obj1.getArea()}\")\n\nTypeError: Can't instantiate abstract class Square with abstract method getArea\n\n\nWe can see above that we have created a Shape class from the ABC class which has an abstract method getArea. Since our child class Square didn’t have getArea implemented we get an error instantiating this class.\n\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    def __init__(self, name):\n        self.name = name\n    \n    @abstractmethod\n    def getArea(self):\n        pass\n    \n    def printDetails(self):\n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \nclass Square(Shape):\n    def __init__(self, edge):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Square\")\n        self.edge = edge\n    \n    def getArea(self): return self.edge**2\n    \nobj1 = Square(4)\nprint(f\"Area of this {obj1.name} is {obj1.getArea()}\")\n\nArea of this Square is 16\n\n\nWe can see above, once we implemented the getArea method, the code runs fine.\n\nAbstract base classes serve as a blueprint for derived classes to implement methods that are required to run the function appropriately."
  },
  {
    "objectID": "posts/31st day/Python_OOPs.html#conclusion",
    "href": "posts/31st day/Python_OOPs.html#conclusion",
    "title": "Python OOPs fundamentals",
    "section": "8 Conclusion",
    "text": "8 Conclusion\nIn this article, we learned about what is object-oriented programming and key concepts using Python. A good understanding of these concepts will lay a solid foundation for any software professional to write and understand python code better.\nI hope you enjoyed reading it. If there is any feedback on the code or just the blog post, feel free to comment below or reach out on Twitter."
  },
  {
    "objectID": "posts/post-with-code/Python_OOPs.html",
    "href": "posts/post-with-code/Python_OOPs.html",
    "title": "Python OOPs fundamentals",
    "section": "",
    "text": "An introduction to Object Oriented programming using Python.\nIncreasingly it’s becoming important for Data professionals to become better at programming and modern programming is centered around Object Oriented programming paradigm. This article helps in explaining some important programming concepts which are mostly language agnostic but we will be using Python in this article.\nObject-oriented programming (OOPs) is a programming paradigm that relies on the concept of classes and objects. The basic idea of OOP is to divide a sophisticated program into a number of objects that interact with each other to achieve the desired functionality. There are several advantages of using OOP for data science:\nOverall, OOP can help data professionals organize and manage their code more effectively, making it easier to develop and maintain data science projects. Let’s dive into the OOPs concept."
  },
  {
    "objectID": "posts/post-with-code/Python_OOPs.html#what-are-objects-and-classes",
    "href": "posts/post-with-code/Python_OOPs.html#what-are-objects-and-classes",
    "title": "Python OOPs fundamentals",
    "section": "1 What are Objects and Classes?",
    "text": "1 What are Objects and Classes?\nClasses are the blueprint for defining an Object. While an Object is a collection of data/properties and their behaviors/methods.\nFor example- Think of a class Bulb that will have a state (On/Off) and methods to turnOn and turnoff the bulb.\n\nclass Bulb():\n    def __init__(self, onOff=False): self.onOff = onOff    \n    def turnOn(self): self.onOff = True\n    def turnOff(self): self.onOff = False\n\nNow we can create multiple bulb objects from this Bulb class.\n\nb1 = Bulb(onOff=True)\nb2 = Bulb()\nprint(f\"Bulb 1 state is :{b1.onOff}, Bulb 2 state is :{b2.onOff}\")\n\nBulb 1 state is :True, Bulb 2 state is :False\n\n\nb1 and b2 are objects of the class Bulb. Let’s use the turnOn and turnOff methods to update the bulb properties.\n\nb1.turnOff(); b2.turnOn()\nprint(f\"Bulb 1 state is :{b1.onOff}, Bulb 2 state is :{b2.onOff}\")\n\nBulb 1 state is :False, Bulb 2 state is :True\n\n\nWe can see from the example above, a Bulb object contains the onOff property. Properties are variables that contain information regarding the object of a class and Methods like turnOn and turnOff in our Bulb class are functions that have access to the properties of a class. Methods can accept additional parameters, modify properties and return values."
  },
  {
    "objectID": "posts/post-with-code/Python_OOPs.html#class-and-instance-variables",
    "href": "posts/post-with-code/Python_OOPs.html#class-and-instance-variables",
    "title": "Python OOPs fundamentals",
    "section": "2 Class and Instance variables",
    "text": "2 Class and Instance variables\nIn Python, properties can be defined in two ways -\n\nClass Variables - Class variables are shared by all objects of the class. A change in the class variable will change the value of that property in all the objects of the class.\nInstance Variables - Instance variables are unique to each instance or object of the class. A change in instance variable will change the value of the property in that specific object only.\n\n\nclass Employee:\n    # Creating a class variable\n    companyName = \"Apple\"\n    \n    def __init__(self, name):\n        # creating an instance variable\n        self.name = name\n    \ne1 = Employee('Abhi')\ne2 = Employee('Manyu')\n\nprint(f'Name :{e1.name}')\nprint(f'Company Name: {e1.companyName}')\nprint(f'Name :{e2.name}')\nprint(f'Company Name: {e2.companyName}')\n\nName :Abhi\nCompany Name: Apple\nName :Manyu\nCompany Name: Apple\n\n\nWe can see above, the class variable is defined outside of the initializer and the instance variable is defined inside the initializer.\n\nEmployee.companyName = \"Microsoft\"\nprint(e1.companyName, e2.companyName)\n\nmicrosoft microsoft\n\n\nWe can see above changing a class variable in the Employee class changes the class variable in all objects of the class. Most of the time we will be using instance variables but knowledge about class variables can come in handy. Let’s look at an interesting use of class variable -\n\nclass Employee:\n    # Creating a class variable\n    companyName = \"Microsoft\"\n    companyEmployees = []\n    \n    def __init__(self, name):\n        # creating an instance variable\n        self.name = name\n        self.companyEmployees.append(self.name)\n    \ne1 = Employee('Abhi')\ne2 = Employee('Manyu')\n\nprint(f'Name :{e1.name}')\nprint(f'Team Members: {e1.companyEmployees}')\nprint(f'Name :{e2.name}')\nprint(f'Company Name: {e2.companyEmployees}')\n\nName :Abhi\nTeam Members: ['Abhi', 'Manyu']\nName :Manyu\nCompany Name: ['Abhi', 'Manyu']\n\n\nWe can see above, we are saving all objects of the Employee class in companyEmployees which is a list shared by all objects of the class Employee."
  },
  {
    "objectID": "posts/post-with-code/Python_OOPs.html#class-static-and-instance-methods",
    "href": "posts/post-with-code/Python_OOPs.html#class-static-and-instance-methods",
    "title": "Python OOPs fundamentals",
    "section": "3 Class, Static and Instance methods",
    "text": "3 Class, Static and Instance methods\nIn Python classes, we have three types of methods -\n\nClass Methods - Class methods work with class variables and are accessible using the class name rather than its object.\nStatic Methods - Static methods are methods that are usually limited to class only and not their objects. They don’t typically modify or access class and instance variables. They are used as utility functions inside the class and we don’t want the inherited class to modify them.\nInstance Methods - Instance methods are the most used methods and have access to instance variables within the class. They can also take new parameters to perform desired operations.\n\n\nclass Employee:\n    # Creating a class variable\n    companyName = \"Microsoft\"\n    companyEmployees = []\n    \n    def __init__(self, name):\n        # creating an instance variable\n        self.name = name\n        self.companyEmployees.append(self.name)\n    \n    @classmethod\n    def getCompanyName(cls): # This is a class method\n         return cls.companyName\n    \n    @staticmethod\n    def plusTwo(x): # This is a static method\n        return x+2\n    \n    def getName(self): # This is an instance method\n        return self.name\n    \ne1 = Employee('Abhi')\nprint(f\"Calling class method. Company name is {e1.getCompanyName()}\")\nprint(f\"Calling Static method. {e1.plusTwo(2)}\")\nprint(f\"Calling instance method. Employee name is {e1.getName()}\")\n\nCalling class method. Company name is Microsoft\nCalling Static method. 4\nCalling instance method. Employee name is Abhi\n\n\nWe can see above we use the @classmethod decorator to define the class method. cls is used to refer to the class just as self is used to refer to the object of the class. The class method at least takes one argument cls.\n\n\n\n\n\n\nNote\n\n\n\nWe can use any other name instead of cls but cls is used as a convention.\n\n\nWe use @staticmethod decorator to define static class plusTwo. We can see that static methods don’t take any argument like self and cls.\nThe most commonly used methods are instance methods and they can be defined without a decorator within the class. Just like the class method they take at least one argument which is self by convention.\n\n\n\n\n\n\nNote\n\n\n\nWe can use any other name instead of self but self is used as a convention."
  },
  {
    "objectID": "posts/post-with-code/Python_OOPs.html#access-modifiers",
    "href": "posts/post-with-code/Python_OOPs.html#access-modifiers",
    "title": "Python OOPs fundamentals",
    "section": "4 Access Modifiers",
    "text": "4 Access Modifiers\nAccess modifiers limit access to the variables and functions of a class. There are three types of access modifiers - public, protected, and private.\n\n4.1 Public Attributes\nPublic attributes are those methods and properties which can be accessed anywhere inside and outside of the class. By default, all the member variables and functions are public.\n\nclass Employee:\n    def __init__(self, name):\n        self.name = name ## Public variable\n        \n    def getName(self): ## Public method\n        return self.name\n\ne1 = Employee(\"Abhi\")\nprint(f\"Employee Name: {e1.getName()}\")\n\nEmployee Name: Abhi\n\n\nIn the case above, both property name and method getName are public attributes.\n\n\n4.2 Protected Attributes\nProtected attributes are similar to public attributes which can be accessed within the class and also available to subclasses. The only difference is the convention, which is to define each protected member with a single underscore “_”.\n\nclass Employee:\n    def __init__(self, name, project):\n        self.name = name ## Public variable\n        self._project = project ## Protected variable\n        \n    def getName(self): ## Public method\n        return self.name\n    \n    def _getProject(self): ## Protected method\n        return self._project\n    \ne1 = Employee(\"Abhi\", \"Project Warpgate\")\nprint(f\"Employee Name: {e1.getName()}\")\nprint(f\"Project Name: {e1._getProject()}\")\n\nEmployee Name: Abhi\nProject Name: Project Warpgate\n\n\nIn the case above, both property _project and method _getProject are protected attributes.\n\n\n4.3 Private Attributes\nPrivate attributes are accessible within the class but not outside of the class. To define a private attribute, prefix the method or property with the double underscore”_“.\n\nclass Employee:\n    def __init__(self, name, project, salary):\n        self.name = name ## Public variable\n        self._project = project ## Protected variable\n        self.__salary = salary\n        \n    def getName(self): ## Public method\n        return self.name\n    \n    def _getProject(self): ## Protected method\n        return self._project\n    \n    def __getSalary(self): ## Protected method\n        return self.__salary\n    \ne1 = Employee(\"Abhi\", \"Project Warpgate\", \"3500\")\nprint(f\"Employee Name: {e1.getName()}\")\nprint(f\"Project Name: {e1.__getSalary()}\") \n\nEmployee Name: Abhi\n\n\nAttributeError: 'Employee' object has no attribute '__getSalary'\n\n\nWe can see above, __salary property and __getSalary method are both private attributes and when we call them outside of the class they throw an error that the 'Employee' object has no attribute '__getSalary'."
  },
  {
    "objectID": "posts/post-with-code/Python_OOPs.html#encapsulation",
    "href": "posts/post-with-code/Python_OOPs.html#encapsulation",
    "title": "Python OOPs fundamentals",
    "section": "5 Encapsulation",
    "text": "5 Encapsulation\nEncapsulation in OOP refers to binding data and the methods to manipulate that data together in a single unit, that is, class. Encapsulation is usually used to hide the state and representation of the object from the outside. A good use of encapsulation is to make all properties private of a class to prevent direct access from outside and use public methods to let the outside world communicate with the class.\n\nclass Employee:\n    def __init__(self, name, project, salary):\n        self.__name = name ## Public variable\n        self.__project = project ## Protected variable\n        self.__salary = salary\n        \n    def getName(self): ## Public method\n        return self.__name\n    \ne1 = Employee(\"Abhi\", \"Project Warpgate\", \"3500\")\nprint(f\"Employee Name: {e1.getName()}\")\n\nEmployee Name: Abhi\n\n\nEncapsulation has several advantages -\n\nProperties of the class can be hidden from the outside world\nMore control over what the outside world can access from the class\n\nA good example of encapsulation would be an access control class based on username and password.\n\nclass Auth:\n    def __init__(self, userName=None, password=None):\n        self.__userName = userName\n        self.__password = password\n        \n    def login(self, userName, password):\n        if (self.__userName == userName) and (self.__password == password):\n            print (f\"Access granted to {userName}\")\n        else:\n            print(\"Invalid credentials\")\n            \ne1 = Auth(\"Abhi\", \"whatever\")\ne1.login(\"Abhi\", \"whatever\") ## This will grant access\n\ne1.login(\"Abhi\", \"aasdasd\") ## This will say invalid creds\ne1.__password ## This will raise an error as private properties can't be accessed from outside.\n\nAccess granted to Abhi\nInvalid credentials\n\n\nAttributeError: 'Auth' object has no attribute '__password'\n\n\nAs we can see above __username and __password are protected properties and can only be used by the class to grand or reject access requests."
  },
  {
    "objectID": "posts/post-with-code/Python_OOPs.html#inheritance",
    "href": "posts/post-with-code/Python_OOPs.html#inheritance",
    "title": "Python OOPs fundamentals",
    "section": "6 Inheritance",
    "text": "6 Inheritance\nInheritance provides a way to create new classes from the existing classes. The new class will inherit all the non-private attributes(properties and methods) from the existing class. The new class can be called a child class and the existing class can be called a parent class.\n\nimport math\nclass Shape:\n    def __init__(self, name):\n        self.name = name\n        \n    def getArea(self):\n        pass\n    \n    def printDetails(self):\n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \nclass Square(Shape):\n    def __init__(self, edge):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Square\")\n        self.edge = edge\n    \n    ## Overiding the getArea function\n    def getArea(self):\n        return self.edge**2\n    \nclass Circle(Shape):\n    def __init__(self, radius):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Circle\")\n        self.radius = radius\n    ## Overiding the getArea function\n    def getArea(self):\n        return math.pi * (self.radius**2)\n    \nobj1 = Square(4)\nobj1.printDetails()\n\nobj2 = Circle(3)\nobj2.printDetails()\n\nThis shape is called Square and area is 16.\nThis shape is called Circle and area is 28.274333882308138.\n\n\nWe can see above we defined a parent class Shape and then we inherited it to create a Square and Circle child class. While defining the Square and Circle class we overwrote the getArea function pertinent to the class but we used the printDetails function from the parent class to print details about child classes. The more common example in the machine learning world would be to create your own models in Pytorch where we inherit from nn.Module class to create a new model.\n\n6.1 Use of super() Function\nsuper() function comes into play when we implement inheritance. The super() function is used to refer to the parent class without explicitly naming the class. super() function can be used to access parent class properties, calling the parent class, and can be used as initializers. Let’s look at the example above and see how we can modify the Square class to use super() function.\n\nclass Shape:\n    maxArea = 100\n    def __init__(self, name): self.name = name\n    def getArea(self): pass\n    def printDetails(self): \n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \n\nclass Square(Shape):\n    maxArea = 50\n    def __init__(self, edge):\n        super().__init__(name = \"Square\") ## Initializing parent class\n        self.edge = edge\n    \n    def getName(self):\n        return super().maxArea\n    \n    def getArea(self):\n        return self.edge**2\n    \n    def printDetails(self):\n        super().printDetails() ## Calling a parent class function\n        print(f\"Max area from Shape class: {super().maxArea}\") ## Accessing parent class property\n        print(f\"Max area from Square class: {self.maxArea}\")\n\nobj1 = Square(4)\nobj1.getName()\nobj1.printDetails()\n\nThis shape is called Square and area is 16.\nMax area from Shape class: 100\nMax area from Square class: 50\n\n\nAs we can see in the example above we have used -\n\nsuper().__init__ to initialize the parent Shape class\nsuper().printDetails() function to use a method from parent class\nsuper().maxArea to access a property of a parent class\n\nThere are many advantages of inheritance -\n\nReusability - Inheritance makes the code reusable. Common methods and properties can be stored in a parent class and child classes can inherit these methods.\nModification - Code modification becomes easier if we use inheritance, if we want to make a change in the base class function it will be propagated to the child classes.\nExtensibility - We can derive new classes from the old ones by keeping things we need in the derived class."
  },
  {
    "objectID": "posts/post-with-code/Python_OOPs.html#polymorphism",
    "href": "posts/post-with-code/Python_OOPs.html#polymorphism",
    "title": "Python OOPs fundamentals",
    "section": "7 Polymorphism",
    "text": "7 Polymorphism\nPolymorphism refers to the same object exhibiting different forms and behaviors. For example consider our shape class which could be a square, rectangle, polygon, etc. Instead of writing multiple functions to get the area of these shapes, we can use a common function like getArea() and implement this function in the derived class.\n\nimport math\nclass Shape:\n    def __init__(self, name):\n        self.name = name\n        \n    def getArea(self):\n        pass\n    \n    def printDetails(self):\n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \nclass Square(Shape):\n    def __init__(self, edge):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Square\")\n        self.edge = edge\n    \n    ## Overiding the getArea function\n    def getArea(self):\n        return self.edge**2\n    \nclass Circle(Shape):\n    def __init__(self, radius):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Circle\")\n        self.radius = radius\n    ## Overiding the getArea function\n    def getArea(self):\n        return math.pi * (self.radius**2)\n    \nobj1 = Square(4)\nprint(f\"Area of this {obj1.name} is {obj1.getArea()}\")\n\nobj2 = Circle(3)\nprint(f\"Area of this {obj2.name} is {obj2.getArea()}\")\n\nArea of this Square is 16\nArea of this Circle is 28.274333882308138\n\n\nAs we can see above there is a pre-defined dummy method called getArea in the Shape class. We override this method in the Square and Circle class. This technique is called method overriding. The advantage of method overriding is that the derived class can write its own specific implementation based on the requirement while using the same function name.\n\n7.1 Abstract base classes\nAbstract base classes define a set of methods and properties that a class must implement in order to inherit the parent class. This is a useful technique to enforce that certain functions within the derived class must exist. To define an abstract base class, we use the abc module. The abstract base class inherits from the built-in ABC class and we use the decorator @abstractmethod to declare an abstract method.\n\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    def __init__(self, name):\n        self.name = name\n    \n    @abstractmethod\n    def getArea(self):\n        pass\n    \n    def printDetails(self):\n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \nclass Square(Shape):\n    def __init__(self, edge):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Square\")\n        self.edge = edge\n    \nobj1 = Square(4)\nprint(f\"Area of this {obj1.name} is {obj1.getArea()}\")\n\nTypeError: Can't instantiate abstract class Square with abstract method getArea\n\n\nWe can see above that we have created a Shape class from the ABC class which has an abstract method getArea. Since our child class Square didn’t have getArea implemented we get an error instantiating this class.\n\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    def __init__(self, name):\n        self.name = name\n    \n    @abstractmethod\n    def getArea(self):\n        pass\n    \n    def printDetails(self):\n        print(f\"This shape is called {self.name} and area is {self.getArea()}.\")\n        \nclass Square(Shape):\n    def __init__(self, edge):\n        ## calling the constructor from parent class Shape\n        Shape.__init__(self, name = \"Square\")\n        self.edge = edge\n    \n    def getArea(self): return self.edge**2\n    \nobj1 = Square(4)\nprint(f\"Area of this {obj1.name} is {obj1.getArea()}\")\n\nArea of this Square is 16\n\n\nWe can see above, once we implemented the getArea method, the code runs fine.\n\nAbstract base classes serve as a blueprint for derived classes to implement methods that are required to run the function appropriately."
  },
  {
    "objectID": "posts/post-with-code/Python_OOPs.html#conclusion",
    "href": "posts/post-with-code/Python_OOPs.html#conclusion",
    "title": "Python OOPs fundamentals",
    "section": "8 Conclusion",
    "text": "8 Conclusion\nIn this article, we learned about what is object-oriented programming and key concepts using Python. A good understanding of these concepts will lay a solid foundation for any software professional to write and understand python code better.\nI hope you enjoyed reading it. If there is any feedback on the code or just the blog post, feel free to comment below or reach out on Twitter."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Experiments with Tech",
    "section": "",
    "text": "Python OOPs fundamentals\n\n\n\n\n\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 31, 2023\n\n\nAbhi\n\n\n\n\n\n\n  \n\n\n\n\nPython OOPs fundamentals\n\n\n\n\n\n\n\nProgramming\n\n\n\n\n\n\n\n\n\n\n\nOct 31, 2023\n\n\nAbhi\n\n\n\n\n\n\n  \n\n\n\n\nPost With Code\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nSep 20, 2023\n\n\nHarlow Malloc\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nSep 17, 2023\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  }
]